const gameboard = require('./factories/gameboard');

function gameLoop() {
  const playerBoard = gameboard('.playerBoard');
  const computerBoard = gameboard('.computerBoard');
  let onGoing = true;
  let winner;
  let shipBeingDragged;

  computerBoard.placeRandomShips(10);

  (function displayShips() {
    playerBoard.ships.forEach((ship) => {
      const tr = document.querySelector(`.playerBoard tr[data-row='${ship.pos.row}']`);
      const td = tr.querySelector(`td[data-column='${ship.pos.column}']`);

      td.style.backgroundColor = 'lightgrey';
    });

    computerBoard.ships.forEach((ship) => {
      const tr = document.querySelector(`.computerBoard tr[data-row='${ship.pos.row}']`);
      const td = tr.querySelector(`td[data-column='${ship.pos.column}']`);

      td.style.backgroundColor = 'lightgrey';
    });
  }());

  const playerTds = document.querySelectorAll('.playerBoard td[data-column]');
  const shipDraggables = document.querySelectorAll('.ship');
  const computerTds = document.querySelectorAll('.computerBoard td[data-column]');

  function canPlaceShipOnSquare(column, row) {
    const square = playerBoard.getSquare(column, row);

    return (square === null);
  }

  function updateDraggedShip(targetTd) {
    const parent = targetTd.parentNode;
    const [column, row] = [targetTd.dataset.column, parent.dataset.row];
    shipBeingDragged.style.backgroundColor = 'rgba(180, 180, 180, 0.4)';
    shipBeingDragged.dataset.column = column;
    shipBeingDragged.dataset.row = row;
  }

  function addShipToBoard() {
    const { column, row } = shipBeingDragged.dataset;
    playerBoard.placeShip(column, row);
  }

  (function configureDraggables() {
    function allowDrop(ev) {
      ev.preventDefault();
    }

    function drag(ev) {
      shipBeingDragged = ev.target;
      const { column, row } = shipBeingDragged.dataset;

      if (column != -1) playerBoard.removeShip(column, row);

      ev.dataTransfer.setData('ship', ev.target.id);
    }

    function drop(ev) {
      const tdParent = ev.target.parentNode;
      const [column, row] = [ev.target.dataset.column, tdParent.dataset.row];
      if (!canPlaceShipOnSquare(column, row)) return;

      ev.preventDefault();
      const data = ev.dataTransfer.getData('ship');
      ev.target.appendChild(document.getElementById(data));

      updateDraggedShip(ev.target);
      addShipToBoard();
      shipBeingDragged = null;
    }

    playerTds.forEach((square) => {
      square.addEventListener('drop', drop);
      square.addEventListener('dragover', allowDrop);
    });

    shipDraggables.forEach((draggable) => {
      draggable.setAttribute('draggable', true);
      draggable.addEventListener('dragstart', drag);
    });
  }());

  function displayWinner() {
    console.log(`${winner} won the match!`);
  }

  computerTds.forEach((el) => {
    el.addEventListener('click', () => {
      if (!onGoing) return;

      const parent = el.parentNode;
      const { column } = el.dataset;
      const { row } = parent.dataset;

      const computerAttack = computerBoard.receiveAttack(column, row);

      if (!computerAttack) {
        console.log('Can"t attack the same square twice.');
      } else {
        if (computerAttack == 'Game Over') {
          onGoing = false;
          winner = 'Player';
          displayWinner();
        }

        const playerAttack = playerBoard.receiveRandomAttack();
        if (playerAttack == 'Game Over') {
          onGoing = false;
          winner = 'Computer';
          displayWinner();
        }
      }
    });
  });
}
gameLoop();
